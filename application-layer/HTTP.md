#### 一、HTTP简介

- 传输层使用TCP

  - 客户端发起一个与服务器的TCP连接(建立套接字)，端口号为80
  - 服务器接收客户端的TCP连接
  - 在浏览器与Web服务器交换HTTP报文(应用层协议报文)
  - TCP连接关闭

- HTTP是无状态的

  服务器并不维护关于客户的任何信息

- 维护状态的协议很复杂！

  - 必须维护历史信息(状态)
  - 如果服务器/客户端死机，它们的状态信息可能不一致，但二者的信息必须一致
  - 无状态的服务器能够支持更多的客户端

  Web服务器启动后，创建一个守护Socket，监听80号端口，当有客户端浏览器发起请求时，会创建不同的连接Socket，维持会话关系

  

#### 二、HTTP连接

- HTTP1.0(非持久)

  - 客户端发起一个到服务器80端口的连接
  - HTTP服务器在80端口等待连接，接收连接并通知客户端
  - HTTP客户端向TCP连接的套接字发送HTTP请求报文
  - HTTP服务器收到请求报文，封装响应报文，并通过套接字向客户端发送
  - 客户端断开连接

     <!--该请求响应过程中，如果客户端需要向同一个HTTP服务器发送资源请求，则需要建立新的TCP连接-->

- HTTP1.1(持久)

  特性：

  - 持久化连接以支持连接重用
  - 分块传输编码以支持流失响应
  - 请求管道以支持并行请求处理
  - 字节服务以支持基于范围的资源请求
  - 更好的缓存机制

  Web请求：

  ​		一个普通的Web请求，前三步与HTTP1.0一样，只是客户端在给服务端发送请求后，如果有新的	请求也是发送到同一个HTTP服务器，无需建立新的TCP连接，可以直接复用已经建立的TCP连接；	并且服务器发送完给客户端的两次响应报文后，客户端并不马上关闭连接，如果客户端继续向服务	器发送请求，可以复用第一次请求已经建立起来的TCP连接，复用方式有以下两种：

  - 流水线方式

    第一个请求发出后，拿到服务器响应报文再继续发第二个请求

  - 非流水线方式

    第一个请求发出后，无需等待服务器响应报文，就继续发第二个请求

  特性详解：

  - HTTP管道

    持久HTTP对于多次请求必须满足FIFO的队列顺序：发送请求、等待响应完成，再发送新的请求，对于服务器而言，上一次响应报文的发出到下一次请求的接收这段时间处于空闲状态。

    HTTP管道可以让我们把FIFO队列从客户端(请求队列)迁移到服务器(响应队列)，HTTP管道允许使用非流水线的方式把请求发送到服务端，服务器可以并行处理这些请求，为这些请求封装响应资源，然后按照响应顺序，把一个个响应报文发送给客户端。

    **队首阻塞**：

    在HTTP1.1中，多个请求同时到达服务端时，服务器可以并行处理这些请求，但它只能严格地串行返回响应。特别是，不允许一个连接上地多个响应数据交错到达(多路复用)，因而一个响应必须完全返回后，下一个响应才会开始传输。

    例子：

    - 客户端发出HTML和CSS的请求同时到达，但先处理的是HTML请求
    - 服务并行处理这两个请求，其中处理HTML耗时50ms，处理CSS用时30ms
    - CSS请求处理先处理完成，但被缓存起来以等待HTML响应
    - 发送完HTML响应后，再发送服务器缓冲中的CSS响应

    <!--在上面的例子中，即使客户端同时发送了两个请求，而且CSS资源先准备就绪，服务器也会先发送HTML响应，然后再交付CSS。这种情况通常称作队首阻塞。-->

    实际中，由于HTTP1.1不可能实现多路复用，HTTP管道会导致HTTP服务、代理和客户端出现很多问题

    - 一个慢响就应会阻塞所有后续请求
    - 并行处理时，服务器必须缓冲管道中的响应，从而占用服务器资源
    - 响应失败可能终止TCP连接，从而强迫客户端端重发对所有后续资源的请求，服务器重复处理
    - 如果存在中间代理，检测管道兼容性，确保可靠性很重要。如果中间代理不支持管道，则它可能会中断连接，也可能会把所有请求串联起来		

  - 使用多个TCP连接

    HTTP1.1提供的管道的方式会带来很多额外的问题，实际生产用的比较少，然而通过客户端FIFO队列的形式在实践中太慢，为了解决这个问题，浏览器支持客户端并行打开多个TCP会话，现实中，大多数现在浏览器，包括桌面和移动浏览器都支持**每个主机**打开6个连接。

    多个TCP连接需要的资源：

    - 客户端可以并行分派最多6个请求
    - 服务器可以并行处理最多6个请求
    - 第一次往返可以发送的累计分组数量(TCP cwnd)增长为原来的6倍

    在没有管道的情况下，最大请求数与打开的连接数相同。对应的，TCP拥塞窗口也要乘以打开的数量，从而允许客户端绕开由TCP慢启动规定的分组限制。这种方法的代价：

    - 多个套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和CPU时钟周期
    - 并行TCP流之间竞争共享的宽带
    - 由于使用多个套接字，实现复杂性更高
    - 即使并行TCP流，应用的并行能力也受限制

- HTTP2.0

  

#### 三、请求/响应报文

- HTTP请求报文

  - 两种类型的HTTP报文：请求、响应

  - HTTP请求报文组成部分(ASCⅡ编码)

    ![image-20210606085457078](https://raw.githubusercontent.com/sermonlizhi/picture/main/image-20210606085457078.png)

    GET	/somedir/page.html	HTTP/1.1

    请求行：GET、POST、HEAD(只请求页面头部)命令

    首部行：Host、User-agent(用户代理程序)、Connection、Accept-language

    换行回车符：表示报文结束(一个额外的换行回车符)

    **通用格式**

    request line：Method|sp|URL|sp|version|cr if

    header  line：header field name:value |cr if

    cr if

    Entity Body

  - 提交表单输入

    - Post方式

      网页通常包括表单输入

      包含在实体主体(Entity Body)中的输入被提交到服务器

    - URL方式

      方法：Get

      输入行通过请求行的URL字段上载(URL+?参数1&参数2)

- HTTP响应报文

  ​	HTTP/1.1 200 OK\r\n

  ​	Connection	close\r\n

  ​	Date：Thu，06 Aug	2021	9:00:11 GMT\r\n

  ​	Server：Apache/1.3.0(Unix)	\r\n  ——服务端Web服务器及版本

  ​	Last-Modified：Mon，22 Jun	2021....\r\n ——服务器资源上一次修改的日期

  ​	Content-Length：6821\r\n

  ​	Content-Type：text/html	\r\n

  ​	data	data	data ——数据，如请求的HTML文件

  状态行：协议版本、状态码、相应状态信息

  首部行：连接状态、服务器信息、响应报文长度、响应报文格式

  响应数据：HTML文件等

- 用户-服务器状态：cookies

  大多数主要的门户网站使用cookies

  第一次访问某网站时，服务器端生成一个cookie并存储，在响应报文中，把cookie发送给用户端，用户端在本地文件系统进行存储，当下一次再次访问该网站时，在请求头带上cookie信息，服务端就能识别到该客户端，将无状态的HTTP变成了有状态的HTTP

  四个组成部分：

  - 在HTTP响应报文中有一个cookie的首部行(第一次访问)
  - 在HTTP请求报文含有一个cookie的首部行
  - 在用户端系统中保留有一个cookie文件，由用户的浏览器管理
  - 在Web站点有一个后端数据库，用于存储cookie信息

#### 四、Web缓存

`不访问原始服务器，就满足客户的请求(静态资源)`

- 用户设置浏览器：通过缓存访问Web(本地缓存)

- 浏览器将所有的HTTP请求发给缓存(代理服务器)

  - 在缓存中的资源，缓存直接响应资源
  - 如果资源不在缓存中，缓存请求原始服务器，然后再将资源返回给客户端

- 缓存既是客户端又是服务器，通常缓存是由ISP安装

- 为什么使用缓存？

  - 降低客户端的请求响应时间
  - 可以大大减少一个机构内部网络与Internet接入链路上的流量(在本地区域网添加代理服务器)
  - 互联网大量采用了缓存：可以使较弱的ICP也能够有效提供内容

- 缓存服务器与Web服务器数据不同步问题解决方案

  HTTP协议有一种机制，允许缓存器证实它的对象是最新的，这种机制就是**条件GET**(conditional GET)方法。

  **条件GET方法**：1、请求报文使用GET方法  2、请求报文中包含一个“If-Modified-Since:”首部行。那么，这个HTTP请求报文就是一个条件GET请求报文。

  条件GET的使用：

  - 缓存服务器向Web服务器发送资源请求

    请求报文：

    GET   /fruit/kiwi.gif  HTTP/1.1

    Host:www.baidu.com

    响应报文：

    HTTP/1.1 200 OK

    Date:……

    Server:……

    Last-Modified：Web，9 Sep 2021 09:29:24

    Content-Type：application/json

    (data	data	data	data	……)

    缓存服务器在将资源发送到请求的浏览器的同时，也在本地缓存了该资源，同时还存储了最后修改时间Last-Modified

  - 隔了一段时间后，Web服务器端的资源可能发生变更，导致与缓存服务器的数据不一致，此时缓存服务器向Web服务器发送一个条件GET执行最新检查。

    请求头：

    GET   /fruit/kiwi.gif  HTTP/1.1

    Host:www.baidu.com

    If-modified-since：Web，9 Sep 2021 09:29:24

    首部行的If-modified-since值等于缓存服务器存储的资源对应Last-Modified的值。该条件GET报文告诉Web服务器缓存服务器中资源上次修改的时候，Web服务器比较本地资源的上次修改时间是否大于缓存服务器中资源的上次修改时间，如果发生了修改，则将修改后的资源响应给缓存服务器；如果没有修改，则响应304状态码：

    HTTP/1.1 304  Not Modified

    Data:……

    Server:……

    (empty	entity	body)

    - 缓存器：在HTTP请求中指定缓存拷贝的时间

      If-modified-since:<date> 

    - 服务器：如果缓存拷贝陈旧(服务器资源没有发生变化)，则响应报文没包含对象

      HTTP/1.1	304	Not Modified

  - Last-Modified/Last-Modified-Since要配合Cache-control使用

    个人理解：如果Cache-control配置了缓存以及缓存时间的时候，Last-Modified/Last-Modified-Since才会有用，当缓存过了有效时间之后，新的请求才会触发条件GET机制

    即使浏览器设置了缓存，当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified将能够很好的减少回应开销

    Cache-control的常见取值：

    - no-cache：数据内容被缓存，但每次请求都重新访问服务器做缓存过期校验，若有max-age，则缓存期间不访问服务器
    - no-store：禁止缓存
    - private(默认)：只能在浏览器中缓存，只有在第一次请求的时候才访问服务器，如有max-age，则缓存期间不访问服务器
    - public：可以被任何缓存区缓存，如：浏览器、服务器、代理服务器
    - max-age：相对过期时间，即以秒为单位的缓存时间
    - no-cache,private：打开新窗口时候重新访问服务器，若设置max-age，则缓存期间不访问服务器
    - private,正数的max-age：后退时候不访问服务器
    - no-cache,正数的max-age：后退时会访问服务器